<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Darkness Planner Shortcut API</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- StarJS is needed for Sun + Moon positions -->
  <script src="StarJs.min.js"></script>

  <!-- SunCalc is not strictly required here, but you might reuse it later -->
  <script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>

  <style>
    /* Minimal styling so that plain JSON is clearly visible in a browser */
    body {
      margin: 0;
      padding: 10px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
      background: #050814;
      color: #f5f7ff;
      white-space: pre-wrap;
      font-size: 14px;
    }
  </style>
</head>
<body>
<script>
  // ------------- Small helpers -------------

  function pad2(n) {
    return n < 10 ? '0' + n : '' + n;
  }

  // Local midnight for a given Date
  function atLocalMidnight(date) {
    const d = new Date(date.getTime());
    d.setHours(0, 0, 0, 0);
    return d;
  }

  // Shift date by N days
  function shiftDays(date, delta) {
    const d = new Date(date.getTime());
    d.setDate(d.getDate() + delta);
    return d;
  }

  // Minutes between two dates
  function diffMinutes(a, b) {
    return Math.round((b.getTime() - a.getTime()) / 60000);
  }

  // ISO date: YYYY-MM-DD (local)
  function fmtDateISO(d) {
    const yyyy = d.getFullYear();
    const mm = pad2(d.getMonth() + 1);
    const dd = pad2(d.getDate());
    return yyyy + '-' + mm + '-' + dd;
  }

  // Human duration: "3 h 20 min" / "45 min"
  function fmtDuration(mins) {
    if (!mins || mins <= 0) return '0 min';
    const h = Math.floor(mins / 60);
    const m = mins % 60;
    if (h > 0) {
      return m > 0 ? (h + ' h ' + m + ' min') : (h + ' h');
    }
    return m + ' min';
  }

  // ------------- Astronomy with StarJS -------------

  function getEventsForDate(midnightLocal, latDeg, lonDeg) {
    if (!window.StarJs || !StarJs.Solar || !StarJs.Time) return null;
    const mjd0 = StarJs.Time.time2mjd(midnightLocal);
    const mjd1 = mjd0 + 1;
    const latRad = latDeg * StarJs.Math.DEG2RAD;
    const lonRad = lonDeg * StarJs.Math.DEG2RAD;
    const arr = StarJs.Solar.sunAndMoonEvents(mjd0, mjd1, lonRad, latRad);
    return arr && arr[0] ? arr[0] : null;
  }

  function getSunTimesForNight(baseDate, latDeg, lonDeg) {
    const mid0 = atLocalMidnight(baseDate);
    const mid1 = shiftDays(mid0, 1);

    const e0 = getEventsForDate(mid0, latDeg, lonDeg);
    const e1 = getEventsForDate(mid1, latDeg, lonDeg);

    const sun0 = e0 && e0.sun ? e0.sun : {};
    const sun1 = e1 && e1.sun ? e1.sun : {};

    const day0 = sun0.day || {};
    const day1 = sun1.day || {};

    const twA0 = sun0.twilightA || {};
    const twA1 = sun1.twilightA || {};

    let sunset = null;
    if (typeof day0.set === 'number') {
      sunset = new Date(mid0.getTime() + day0.set * 3600 * 1000);
    }

    let sunrise = null;
    if (typeof day1.rise === 'number') {
      sunrise = new Date(mid1.getTime() + day1.rise * 3600 * 1000);
    }

    let astrStart = null;
    if (typeof twA0.set === 'number') {
      astrStart = new Date(mid0.getTime() + twA0.set * 3600 * 1000);
    }

    let astrEnd = null;
    if (typeof twA1.rise === 'number') {
      astrEnd = new Date(mid1.getTime() + twA1.rise * 3600 * 1000);
    }

    return { mid0, mid1, sunset, sunrise, astrStart, astrEnd };
  }

  // Full darkness between astronomical twilight times, checking Moon below horizon
  function getFullDarknessForNight(baseDate, latDeg, lonDeg) {
    const sun = getSunTimesForNight(baseDate, latDeg, lonDeg);
    const { astrStart, astrEnd } = sun;

    if (!astrStart || !astrEnd || astrEnd <= astrStart) {
      return { sun, darknessIntervals: [], totalMinutes: 0 };
    }

    const stepMs = 5 * 60 * 1000; // 5 minutes
    const latRad = latDeg * StarJs.Math.DEG2RAD;
    const lonRad = lonDeg * StarJs.Math.DEG2RAD;
    const sinLat = Math.sin(latRad);
    const cosLat = Math.cos(latRad);

    const startMs = astrStart.getTime();
    const endMs   = astrEnd.getTime();

    let intervals = [];
    let inDark = false;
    let runStart = null;

    for (let tMs = startMs; tMs <= endMs; tMs += stepMs) {
      const t = new Date(tMs);

      const mjd = StarJs.Time.time2mjd(t);
      const T = StarJs.Time.mjd2jct(mjd);

      const pos = StarJs.Solar.approxMoon(T);
      const ra  = pos.ra;
      const dec = pos.dec;

      const gmst = StarJs.Time.gmst(mjd);
      const lst  = gmst + lonRad;
      const H    = lst - ra;

      const sinAlt =
        sinLat * Math.sin(dec) + cosLat * Math.cos(dec) * Math.cos(H);
      const alt = Math.asin(sinAlt);

      const nowDark = alt < 0;

      if (nowDark && !inDark) {
        inDark = true;
        runStart = t;
      } else if (!nowDark && inDark) {
        inDark = false;
        intervals.push({ start: runStart, end: new Date(tMs) });
        runStart = null;
      }
    }

    if (inDark && runStart) {
      intervals.push({ start: runStart, end: astrEnd });
    }

    let totalMinutes = 0;
    for (const d of intervals) {
      totalMinutes += diffMinutes(d.start, d.end);
    }

    return { sun, darknessIntervals: intervals, totalMinutes };
  }

  // Overlap between darkness intervals and user time window [fromHour..toHour]
  function getWindowOverlapMinutes(baseDate, darknessIntervals, fromHour, toHour) {
    if (!darknessIntervals || darknessIntervals.length === 0) return 0;

    const baseMid = atLocalMidnight(baseDate);
    const baseMs  = baseMid.getTime();

    let windowStartMs = baseMs + fromHour * 3600000;
    let windowEndMs   = baseMs + toHour   * 3600000;

    // If end is not after start, assume it crosses midnight into the next day
    if (windowEndMs <= windowStartMs) {
      windowEndMs += 24 * 3600000;
    }

    let total = 0;
    for (const interval of darknessIntervals) {
      const s = Math.max(interval.start.getTime(), windowStartMs);
      const e = Math.min(interval.end.getTime(), windowEndMs);
      if (e > s) {
        total += Math.round((e - s) / 60000);
      }
    }
    return total;
  }

  // ------------- Main API logic -------------

  (function main() {
    try {
      const url = new URL(window.location.href);
      const qp  = url.searchParams;

      // Required parameters: lat, lon, from, to, min
      const lat   = parseFloat(qp.get('lat'));
      const lon   = parseFloat(qp.get('lon'));
      const fromH = parseInt(qp.get('from'), 10);
      const toH   = parseInt(qp.get('to'), 10);
      const minH  = parseFloat(qp.get('min') || '0'); // hours
      const dow   = qp.get('dow') || ''; // '', 'fri_sat', 'sat_sun', 'fri_sat_sun'
      const days  = parseInt(qp.get('days') || '30', 10); // how many nights to scan

      // Optional start date: YYYY-MM-DD
      const startStr = qp.get('start'); 
      let startDate;
      if (startStr) {
        const parts = startStr.split('-').map(Number);
        // month - 1 because JS months are 0-based
        startDate = atLocalMidnight(new Date(parts[0], parts[1] - 1, parts[2]));
      } else {
        startDate = atLocalMidnight(new Date());
      }

      // Validate required parameters
      if (!isFinite(lat) || !isFinite(lon) || !isFinite(fromH) || !isFinite(toH)) {
        document.body.textContent = JSON.stringify({
          ok: false,
          error: 'Missing or invalid parameters. Required: lat, lon, from, to, min'
        });
        return;
      }

      const minMinutes = minH > 0 ? Math.round(minH * 60) : 0;

      // Map DOW filter to allowed days
      // JS: Sunday=0, Monday=1, ... Saturday=6
      let allowedDays = null;
      switch (dow) {
        case 'fri_sat':
          allowedDays = [5, 6];
          break;
        case 'sat_sun':
          allowedDays = [6, 0];
          break;
        case 'fri_sat_sun':
          allowedDays = [5, 6, 0];
          break;
        default:
          allowedDays = null; // no restrictions
      }

      // Scan N nights forward
      let found = null;

      for (let i = 0; i < days; i++) {
        const base = shiftDays(startDate, i);
        const dowJs = base.getDay();

        if (allowedDays && !allowedDays.includes(dowJs)) {
          // Day of week is not allowed by filter
          continue;
        }

        const dark = getFullDarknessForNight(base, lat, lon);

        if (!dark.sun.astrStart || !dark.sun.astrEnd || dark.darknessIntervals.length === 0) {
          // No astronomical night or no Moon-below-horizon intervals
          continue;
        }

        const mm = getWindowOverlapMinutes(base, dark.darknessIntervals, fromH, toH);

        if (mm >= minMinutes) {
          found = { date: base, minutes: mm, dark };
          break;
        }
      }

      if (!found) {
        document.body.textContent = JSON.stringify({
          ok: false,
          message: 'No suitable nights in the specified range',
          scannedDays: days
        });
        return;
      }

      // Build a human-friendly message
      const dateISO  = fmtDateISO(found.date);
      const durHuman = fmtDuration(found.minutes);

      const result = {
        ok: true,
        date: dateISO,              // YYYY-MM-DD
        overlapMinutes: found.minutes,
        overlapHuman: durHuman,
        fromHour: fromH,
        toHour: toH,
        scannedDays: days,
        // Optional debug info:
        debug: {
          lat: lat,
          lon: lon,
          minHours: minH,
          dowFilter: dow
        },
        message: `Next good dark window on ${dateISO} with at least ${durHuman}`
      };

      document.body.textContent = JSON.stringify(result);
    } catch (err) {
      document.body.textContent = JSON.stringify({
        ok: false,
        error: 'Unexpected error',
        details: String(err && err.message ? err.message : err)
      });
    }
  })();
</script>
</body>
</html>
